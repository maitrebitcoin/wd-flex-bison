#To edit and compare internal_properties, use WINDEV integrated tools.
#Internal properties refer to the properties of controls in windows, reports, etc.
info :
 name : wdFlex
 major_version : 27
 minor_version : 0
 type : 4
 description : ""
 subtype : 0
class :
 identifier : 0x122df02c004403ca
 internal_properties : BwAAAAcAAAB2/vstTMCJbS/hlxjFxirSqKvCUuv8YxgpWyl7S3iA
 code_elements :
  type_code : 10
  p_codes :
   -
     code : |1+
      wdFlex est une Classe
      	hérite de wd_compilateur_base
      	
      	// Remplis durant la phase de compilation
      
      	// code utilisateur a mettre dans la déclaration de la classe pour ajouter des membre
      	code_wl_declaration est chaine unicode
      	// règles de productions pour le lexer
      	tab_règle_production_lex est un tableau de stToken2Code
      	
      fin
      EEtat est un enumeration
      	Tout_Etat					= 1 
      	Declaration_SymboleEtOption = 2
      	Declaration_CodeUser	    = 3 // entre [% et %]
      	Avant_Règles			    = 4
      	Declaration_Règles		    = 5 // entre  %% et %% final
      	Apres_Règles			    = 6 // après le %% final
      
      
      fin
      // définie la règle a exécuter sur chaque token trouvé durant la compilation
      stToken2Code est une structure
      	// token trouvé. ex: " " ou "34"
      	token		est chaine		
      	// code WL a produire
      	code_wl		est chaine
      FIN
     type : 131072
  procedures :
   -
     name : Constructeur
     procedure_id : 1309967138408432586
     type_code : 27
     code : |1+
      procédure Constructeur()
      
      // Init un tableau a 7 él&ments vide
      :tableau_regle = allouer un tableau de 7 tableaux de wd_compilateur_base::RegleDeProduction 
      // Init des règles de parsing pour produire le lexer
      _ajoute_règle_production(Declaration_SymboleEtOption,  "%{","",     (yyText)=>{ _changeState(Declaration_CodeUser) } )
      _ajoute_règle_production(Declaration_SymboleEtOption,  "",".*",     (yyText)=>{ } ) // pas d'options pour l'instant, on ignore tout
      _ajoute_règle_production(Declaration_CodeUser, 		   "%}","",     (yyText)=>{ _changeState(Avant_Règles) } )
      _ajoute_règle_production(Declaration_CodeUser, 		   "",".*",     (yyText)=>{ :code_wl_declaration += [RC] + yyText } )
      _ajoute_règle_production(Declaration_SymboleEtOption,  "%%","",     (yyText)=>{ _changeState(Declaration_Règles) } )
      _ajoute_règle_production(Avant_Règles, 	 	  		   "%%","",     (yyText)=>{ _changeState(Declaration_Règles) } )
      _ajoute_règle_production(Declaration_Règles, 		   "%%","",     (yyText)=>{ _changeState(Apres_Règles) }  )
      _ajoute_règle_production(Declaration_Règles,  		   "",".*",     (yyText)=>{ _parse_ligne_regle_flex(yyText)  } )
      _ajoute_règle_production(Tout_Etat, 		  		   "","",       (yyText)=>{ } ) // ignorer les lignes vides
      _ajoute_règle_production(Tout_Etat, 		  		   "","[ \t]*", (yyText)=>{ } ) // ignorer les lignes avec que des espaces ou tab
     type : 589824
   -
     name : _parse_ligne_regle_flex
     procedure_id : 1346228860097493441
     type_code : 12
     code : |1+
      // analyser une règle de production du lexer
      // ex: 
      // {blanks}        { /* ignore */ }
      procédure  _parse_ligne_regle_flex(ligne est chaine) 
      
      // ignorer les lignes vides
      si ligne="" ALORS retour
      
      ligne_sans_tab est chaine = remplace(ligne,TAB," ") // TAB ou " " sont équivalents
      
      // recherche de la position de fin de la regexp
      pos_fin_rexp est entier
      dans_crochet est un booléen 
      pour pos_fin_rexp = 1 _a_ taille(ligne_sans_tab)
      	c est chaine = ligne_sans_tab[pos_fin_rexp]
      	selon c
      		CAS " ":
      			 si pas dans_crochet alors sortir
      		cas "[": dans_crochet = vrai
      		cas "]": dans_crochet = faux
      	FIN
      FIN
      // si fin de rexep non trouvée
      si pos_fin_rexp>Taille(ligne_sans_tab) alors
      	// Erreur
      	ExceptionDéclenche(1,"Erreur de syntaxe : " + ligne)
      FIN
      // récupération de l'expression de gauche, ex : "{blanks}"
      expression_gauche est chaine = Gauche(ligne_sans_tab, pos_fin_rexp-1)
      // sauter tous les espaces
      pos_debut_code est un entier = pos_fin_rexp
      tantque expression_gauche[pos_debut_code]=" "
      	pos_debut_code++
      FIN
      // récupération du code utilisateur si on trouve le token <sExpression>
      code_wl_user est chaine =  Milieu(ligne_sans_tab,pos_debut_code)
      // si il a des commentaires de fin de ligne, on les enlève
      position_marque_commentaire est un entier = position(code_wl_user,"//")
      SI 	position_marque_commentaire>0 ALORS
      	code_wl_user = gauche(code_wl_user, position_marque_commentaire-1)	
      FIN
      // pas d'espace
      code_wl_user = SansEspace(code_wl_user,sscExtérieur)
      // "," tout seul est invalide en WL
      if (code_wl_user=";") code_wl_user= ""
      
      // enlever les {} autour du code si il sont présent
      si code_wl_user[1]="{" _et_ droite(code_wl_user,1)="}" ALORS
      	code_wl_user = milieu(code_wl_user,2,taille(code_wl_user)-2)
      FIN
      
      // ajoute a la table
      stInfo est un stToken2Code
      stInfo.token    = expression_gauche
      stInfo.code_wl  = code_wl_user
      tab_règle_production_lex.Ajoute(stInfo)
     type : 458752
   -
     name : Destructeur
     procedure_id : 1309967138408498122
     type_code : 28
     code : |1+
      procédure Destructeur()
     type : 655360
   -
     name : génère_compilateur
     procedure_id : 1309967391812349201
     type_code : 12
     code : |1+
      // génération d'une classe WL sur le disque
      // renvoie (vrai,"") ou (faux,<message d'erreur>)
      procédure génère_compilateur(nom_fichier_source_lex est chaine, nom_fichier_dest est chaine) : (booléen, chaine)
      
      // chargement du fichier .l
      source_lexer est chaine UNICODE = _charge_fichier_source(nom_fichier_source_lex)
      SI ErreurDétectée ALORS
      	// erreur
      	RENVOYER (Faux, ErreurInfo())
      FIN
      
      // init a l'état initial
      _changeState(Declaration_SymboleEtOption)
      // compilation avec le mode spécial ligne a ligne
      soit (ok,message_erreur) = _compile_mode_ligne(source_lexer)
      si pas ok ALORS
      	// erreur
      	RENVOYER (Faux, message_erreur)
      FIN
      
      // génération de la classe sur disque
      (ok,message_erreur)  = _genére_code_wl(nom_fichier_dest)
      SI PAS ok ALORS
      	// erreur
      	RENVOYER (Faux, message_erreur)
      FIN	
      
      // + on copie les dépendances
      _copie_dépendance(nom_fichier_dest)
      SI ErreurDétectée ALORS
      	// erreur
      	RENVOYER (Faux, ErreurInfo())
      FIN
      
      
      // succès de la génération d'une classe WL pour compiler
      renvoyer (Vrai,"")
     type : 458752
   -
     name : _copie_dépendance
     procedure_id : 1346588512062157735
     type_code : 12
     code : |1+
      procédure _copie_dépendance(nom_fichier_dest est chaine)
      
      répertoire_destination est chaine = fExtraitChemin(nom_fichier_dest,fDisque+fRépertoire)
      fCopieFichier("..\wd_compilateur_base.wdc",répertoire_destination)
      
     type : 458752
   -
     name : _charge_fichier_source
     procedure_id : 1346004001379230591
     type_code : 12
     code : |1+
      procédure _charge_fichier_source(nom_fichier_source est chaine) : chaîne UNICODE
      
      // chargement du fichier en binaire
      contenu_fichier_bin est un buffer = fChargeBuffer(nom_fichier_source)
      SI ErreurDétectée ALORS
      	renvoyer ""
      FIN
      si contenu_fichier_bin="" ALORS
      	renvoyer ""
      FIN
      // est-ce de l'utf8 ?
      contenu_fichier_utf8 est chaine ANSI = UTF8VersAnsi(contenu_fichier_bin)
      si contenu_fichier_utf8<>"" ALORS
      	renvoyer UTF8VersUnicode(contenu_fichier_bin)
      FIN
      // ce n'est pas de l'utf8, on traite comme du latin 1
      RENVOYER AnsiVersUnicode(contenu_fichier_bin,alphabetAnsi)
     type : 458752
   -
     name : _changeState
     procedure_id : 1345972635227731108
     type_code : 12
     code : |1+
      // change l'état courant
      procédure _changeState( e EEtat )
      :etat_courant_lexer = e.Valeur
     type : 458752
   -
     name : _genére_code_wl
     procedure_id : 1315080112286971194
     type_code : 12
     code : |1+
      // génération du code du lexer apres un appel a bParse
      procédure protégée _genére_code_wl( nom_fichier_dest est chaine ) : (booléen, chaine)
      dbgAssertion(nom_fichier_dest<>"")
      
      // nom de la classe a crée
      // ex: "c:\temp^mon_parseur.wdc" => "parseur.wdc"
      nom_classe_générée est chaine ansi = fExtraitChemin(nom_fichier_dest,fFichier)
      
      // génération en mémoire du code WL
      ok est un booléen
      code_wl_résultat est une chaine ansi
      message_erreur est chaine
      (ok,code_wl_résultat,message_erreur) = _genère_code_lexer_apres_compilation(nom_classe_générée)
      si pas ok ALORS
      	// erreur
      	RENVOYER (Faux, message_erreur)
      FIN
      
      // sauver le fichier généré sur disque
      fSauveTexte(nom_fichier_dest,code_wl_résultat)
      SI ErreurDétectée ALORS
      	// erreur
      	RENVOYER (Faux, ErreurInfo())
      FIN
      // OK
      RENVOYER (Vrai, "")
     type : 458752
   -
     name : _genère_code_lexer_apres_compilation
     procedure_id : 1345896446802101953
     type_code : 12
     code : |1+
      // génération du code du lexer apres un appel a _compile()
      // renvoie (vrai, <code WL du lexer>, "") ou (faux, "", <message d'erreur>)
      procédure _genère_code_lexer_apres_compilation(nom_classe_générée est chaine ansi) :  (booléen, chaine ansi, chaine)
      
      	procédure interne _to_yaml( local code_wl  est une chaîne UNICODE) : chaine ansi
      		code_yaml_utf8 est chaine ansi =  UnicodeVersAnsi( Remplace( code_wl, RC, rc+"      "), alphabetUTF8) // 6 espace après les Rc pour respecter le format yaml de wd
      		renvoyer code_yaml_utf8 
      	FIN
      
      // chargement du code  wl template
      template_code est chaine ansi = fChargeBuffer("..\\wd_compilateur_template.wdc")
      si ErreurDétectée ALORS
      	// erreur
      	renvoyer (Faux, "", erreurinfo())
      FIN
      
      //  Modifier le nom de la classe
      code_de_travail est une chaine ansi = template_code
      code_de_travail = Remplace(code_de_travail, "wd_compilateur_template", nom_classe_générée)
      
      // Insérer le code user de déclaration
      code_wl_declaration_yaml est chaine ansi = _to_yaml( :code_wl_declaration )
      code_de_travail = Remplace(code_de_travail, "//%CODE_DECLARATION_MEMBRE%", code_wl_declaration_yaml)
      
      // code pour déclarer les règle de production
      // ex : _ajoute_règle_production( STATE,  "%{","",  ()=> { _changeState(Declaration_CodeUser) } )
      nombre_etat_max_lexer est un entier =1
      code_init_ChaineVersToken est chaine = ChaîneConstruit(":tableau_regle = allouer un tableau de %1 tableaux de wd_compilateur_base::RegleDeProduction " , nombre_etat_max_lexer)
      token_vers_code_wl est stToken2Code
      pour tout token_vers_code_wl de :tab_règle_production_lex
      	param_etat est chaine = "Etat_lexer_tous"
      	chaine_exacte est chaine  = """""" // 2 quotes = chaine vide
      	rexgExp est chaine 		 
      	// ex :  (yytext; )=>{ m_sCode_Declaration += [RC] + yytext  } )
      	code_action_lambda est chaine = ChaîneConstruit(" (yytext)=> { %1 }", token_vers_code_wl.code_wl )
      	// si c'est au format "A" => on prend la chaine exacte
      	si token_vers_code_wl.token[1] = """" alors
      		chaine_exacte = token_vers_code_wl.token
      	sinon
      		rexgExp       = token_vers_code_wl.token
      	fin
      	// construit la chaine finale
      	code_init_ChaineVersToken += [RC] + chaineconstruit( "_ajoute_règle_production( %1,%2,""%3"", %4 )", param_etat,chaine_exacte,rexgExp,code_action_lambda )
      FIN
      
      code_init_ChaineVersToken_yaml est chaine ANSI = _to_yaml( code_init_ChaineVersToken)
      code_de_travail= Remplace(code_de_travail,"//%CODE_INIT_CHAINEVERSTOKEN%", code_init_ChaineVersToken_yaml)
      
      // init du code avant compilation
      code_avant_compilation est chaine = "etat_courant_lexer=1"
      code_avant_compilation_yaml est chaine ANSI = _to_yaml( code_avant_compilation )
      code_de_travail= Remplace(code_de_travail,"//%CODE_AVANT_COMPILE%", code_avant_compilation_yaml)
      
      
      
      // OK
      RENVOYER (vrai, code_de_travail, "")
      
     type : 458752
  procedure_templates : []
  property_templates : []
 code_parameters :
  internal_properties : BwAAAAcAAAA6ih3UbgNXHwTtiPSFUEj+2fi/m7v4QV2rqidAupM=
  original_name : Classe1
resources :
 string_res :
  identifier : 0x122df0200041d538
  internal_properties : BwAAAAcAAAAnMYFQ1bL/vz9ehh7L22SNNSlIzGTOI8h5F/WtgDNP
custom_note :
 internal_properties : BwAAAAcAAABtB9HWVzrXO2+4NDRVK0vmzaNKrCKqH1DBX30lMmGZ
