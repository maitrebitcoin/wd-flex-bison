#To edit and compare internal_properties, use WINDEV integrated tools.
#Internal properties refer to the properties of controls in windows, reports, etc.
info :
 name : wd_compilateur_base
 major_version : 27
 minor_version : 0
 type : 4
 description : ""
 subtype : 0
class :
 identifier : 0x12bbe1f100ecf7ba
 internal_properties : BwAAAAcAAAB2/vstTMCJbS/hlxjFxirSqKvCUuv8YxgpWyl7S3iA
 code_elements :
  type_code : 10
  p_codes :
   -
     code : |1-
      wd_compilateur_base est une Classe
      	m_lexer est wd_lexer_base dynamique
      	en_mode_debug est un booléen 
      	
      	// règles de productions générée par wdBidon en fonction du .y
      	tab_règle_grammaire	est un tableau de RegleDeGrammaire		
      	//  #TODO token racine tel que défini par %start
      	token_start est un entier
      	// pile de compilation
      	pile_compilation est une pile de NiveauPile
      	// "" si tout est ok ou erreur en cours
      	dernière_erreur	est chaine		
      fin
      
      CONSTANT TOKEN_EOF   = -1 // fin de fichier
      CONSTANT TOKEN_AUCUN = 0  // aucun token valide
      EActionSurToken est une Enumération
      	Shift			= 1 // lire le token suivant
      	Reduce			= 2 // regroupe les token
      	EndCompile		= 3 // fin de la compilation
      	ErrorCompile	= 4 // lever un erreur de grammamire
      FIN
      RegleDeGrammaire est une structure
      	// n° de la règle
      	numero_règle	est entier
      	// nom pour debug
      	Nom				est chaine
      	// liste des indice de token pour  séparé par ","
      	liste_indices_token est chaine
      	// code a exécuter lors de la réduction
      	code_a_executer est une procédure
      	// nombre de paramètres
      	nombre_de_paramètre est un entier
      FIN
      NiveauPile est une structure
      	// n° de la règle
      	numero_règle	est entier
      	// valeur de $$
      	valeur_user est variant
      fin
      constant SYNTAX_ERROR = <§R13025f3000e43747¤fr-FR¤Erreur de syntaxe : %1§>
     type : 131072
  procedures :
   -
     name : Constructeur
     procedure_id : 1349920938546558906
     type_code : 27
     code : |1+
      procédure Constructeur()
     type : 589824
   -
     name : Destructeur
     procedure_id : 1349920938546624442
     type_code : 28
     code : |1+
      procédure Destructeur()
     type : 655360
   -
     name : _ajoute_regle_grammaire
     procedure_id : 1355635959454801733
     type_code : 12
     code : |1+
      // appelé par la classe générée pour déclarer les règles de grammaires 
      procédure PROTÉGÉE _ajoute_regle_grammaire(numero_règle est un entier, nom chaine, liste_indices_token est une chaîne, code_a_executer est procédure )
      dbgAssertion(nom<>"")
      dbgAssertion(numero_règle>0)
      
      nouvelle_règle est RegleDeGrammaire 
      nouvelle_règle.numero_règle		   = numero_règle
      nouvelle_règle.nom 				   = nom
      nouvelle_règle.liste_indices_token = liste_indices_token
      nouvelle_règle.nombre_de_paramètre = ChaîneOccurrence(liste_indices_token,",") + 1
      nouvelle_règle.code_a_executer	   = code_a_executer
      :tab_règle_grammaire.Ajoute(nouvelle_règle)
     type : 458752
   -
     name : _compile_chaine
     procedure_id : 1349920938546689978
     type_code : 12
     code : |1-
      // point d'entrée interne du compilateur généré
      PROCÉDURE protégée _compile_chaine( source_a_compiler est chaîne UNICODE, lexer est un wd_lexer_base) : booléen
      
      // pile des token en attende de pouvoir générer une règle valide (= faire un reduce)
      pile_token est chaine	
      ligne_encours est entier // yylineno dans flex
      colonne_encours est entier
      	procédure interne _erreur_de_syntaxe()
      		text_ligne_courante	est chaîne	= m_lexer:source_découpée_en_ligne[ligne_encours]
      		chaine_restante		est chaîne	= Milieu( text_ligne_courante,colonne_encours)		
      		_erreur_de_compilation( ChaîneConstruit(::SYNTAX_ERROR, chaine_restante) )
      	FIN
      
      // Init lexer
      m_lexer <- lexer 
      m_lexer.set_source(source_a_compiler)
      m_lexer.etat_courant_lexer = 1 // = Etat_lexer_tous
      
      BOUCLE
      	// récupération du token suivant 
      	ligne_encours   = m_lexer:numéro_ligne_en_cours
      	colonne_encours = m_lexer:numéro_colonne_en_cours
      	valeur_token_courant est entier =  m_lexer.token_suivant()
      	// si c'est la fin du fichier
      	SI valeur_token_courant = TOKEN_EOF  ALORS
      		// on devrait être arrivé a la recine si on en a défini une
      		si token_start<>0 _et_ pile_token<>token_start alors
      			// erreur de la compilation
      			_erreur_de_compilation( ChaîneConstruit(::SYNTAX_ERROR, <§R12ba93c90093b02d¤fr-FR¤Il manque la fin§>))
      			renvoyer faux
      		FIN
      		// compilation OK
      		RENVOYER vrai	
      	FIN
      	// si on a trouvé aucune règle de production valide
      	SI valeur_token_courant = ::TOKEN_AUCUN ALORS
      		// erreur de compilation
      		_erreur_de_syntaxe()
      		RENVOYER Faux		
      	FIN
      	// on calcule ce qu'on doit faire avec ce token
      	action_token est EActionSurToken  
      	numero_regle_reduce est entier
      	(action_token,numero_regle_reduce)= _calcule_action_token(valeur_token_courant, pile_token)
      	SI en_mode_debug ALORS
      		// trace chaque action de la grammaire
      		Trace( m_lexer:yytext + ": token=" + valeur_token_courant + " action="+action_token.Nom )
      	FIN	
      	// effectuer l'action	
      	selon action_token 
      		cas ErrorCompile 
      			// compilation terminée en erreur
      			_erreur_de_syntaxe()
      			RENVOYER Faux		
      		cas Shift	
      			niveau_shift est NiveauPile
      			niveau_shift.numero_règle	= valeur_token_courant
      			niveau_shift.valeur_user	= m_lexer:yytext
      			Empile(  pile_compilation, niveau_shift)
      			pile_token += [","] + valeur_token_courant		
      			// lire le token suivant		
      			CONTINUE 
      		cas EndCompile
      			// compilation terminée OK
      			renvoyer vrai
      		cas Reduce		
      			// push du paramètre en cours
      			niveau_local est NiveauPile
      			niveau_local.numero_règle	= valeur_token_courant
      			niveau_local.valeur_user	= m_lexer:yytext
      			Empile(  pile_compilation, niveau_local)
      			// récup de la règle de réduction 
      			regle_reduce est RegleDeGrammaire dynamique = tab_règle_grammaire[numero_regle_reduce]
      			// nombre de paramètre
      			nbParamètre est entier = regle_reduce.nombre_de_paramètre
      			
      			// regroupe les token
      			// exécuter l'action de la règle numero_regle_reduce
      			
      			// récupération des paramètres dans la pile
      			TableauDesParametres est un tableau de variant 
      			pour i = 1 _a_ nbParamètre
      				niveau_pile_i est NiveauPile
      				Dépile(  pile_compilation, niveau_pile_i )
      				TableauDesParametres.Ajoute(niveau_pile_i.valeur_user)
      			fin//I
      			niveau_courant est NiveauPile
      			niveau_courant.numero_règle = numero_regle_reduce
      			selon nbParamètre
      				CAS 1
      					niveau_courant.valeur_user  = regle_reduce.code_a_executer( TableauDesParametres[1] )			
      				CAS 2
      					niveau_courant.valeur_user  = regle_reduce.code_a_executer( TableauDesParametres[1], TableauDesParametres[2] )
      				CAS 3
      					niveau_courant.valeur_user  = regle_reduce.code_a_executer( TableauDesParametres[1], TableauDesParametres[2], TableauDesParametres[3] )
      				CAS 4
      					niveau_courant.valeur_user  = regle_reduce.code_a_executer( TableauDesParametres[1], TableauDesParametres[2], TableauDesParametres[3], TableauDesParametres[4] )
      				CAS 5
      					niveau_courant.valeur_user  = regle_reduce.code_a_executer( TableauDesParametres[1], TableauDesParametres[2], TableauDesParametres[3], TableauDesParametres[4], TableauDesParametres[5] )
      				CAS 6
      					niveau_courant.valeur_user  = regle_reduce.code_a_executer( TableauDesParametres[1], TableauDesParametres[2], TableauDesParametres[3], TableauDesParametres[4], TableauDesParametres[5], TableauDesParametres[6] )
      				AUTRE CAS
      					dbgAssertion(faux,"A coder")	
      			FIN
      			Empile(  pile_compilation, niveau_courant)
      			pile_token = regle_reduce.numero_règle
      	FIN
      	
      	
      FIN
     type : 458752
   -
     name : _calcule_action_token
     procedure_id : 1349920938546755514
     type_code : 12
     code : |1+
      // calcul de l'action a effecuter dans la grammaire pour un nouveau token rencontré
      // renvoie
      // .L'action a effectuer
      // .le n° de regle Reduce si l'action est un Reduce
      PROCÉDURE _calcule_action_token(token est un entier, pile est chaine) : (EActionSurToken,entier)
      
      SI token = TOKEN_EOF ALORS
      	RENVOYER (ErrorCompile,0)
      FIN
      
      // calcul nouvel état avec ce nouveau token
      pile_avec_token	est chaine	= pile + [","] + token
      taille_pile est entier = ChaîneOccurrence(pile_avec_token,",")-1
      
      // recherche les règles qui peuvent correspondre
      nb_reduce_possible	est entier		= 0
      nb_shift_possible	est entier		= 0
      numero_regle est entier=1
      numero_regle_reduce est entier=0
      POUR TOUT regle_de_grammaire DE :tab_règle_grammaire
      	// si c'est exactement cette règle
      	si regle_de_grammaire.liste_indices_token = pile_avec_token ALORS
      		// trouvé
      		renvoyer  (Reduce,numero_regle )
      	FIN
      	// si cette règle est la fin de la pile
      	si pile_avec_token.finitpar(regle_de_grammaire.liste_indices_token ) ALORS
      		numero_regle_reduce= numero_regle
      		nb_reduce_possible++
      	FIN
      	// si cette règle peut être produite avec plus de token
      	SI regle_de_grammaire.liste_indices_token.CommencePar( pile_avec_token ) ALORS
      		nb_shift_possible++
      	FIN	
      	numero_regle++
      FIN
      
      // si 1 seule regle possible
      si nb_reduce_possible=1 ALORS
      	RENVOYER  (Reduce,numero_regle_reduce )
      FIN
      // si plusieurs regles encore possible
      SI nb_reduce_possible>1 ALORS
      	RENVOYER  (Shift,0 )
      FIN
      SI nb_shift_possible>0 ALORS
      	RENVOYER  (Shift,0 )
      FIN
      
      //  aucune règle ne peut correspondre
      // => erreur de grammaire
      renvoyer (ErrorCompile,0)
      
     type : 458752
   -
     name : _erreur_de_compilation
     procedure_id : 1349920938546821050
     type_code : 12
     code : |1+
      // lever une erreur de compilation
      procédure _erreur_de_compilation( message_erreur est chaine)
      
      text_ligne_courante	est chaîne
      si m_lexer:numéro_ligne_en_cours <= m_lexer:source_découpée_en_ligne.Occurrence()
       	text_ligne_courante	 = m_lexer:source_découpée_en_ligne[m_lexer:numéro_ligne_en_cours]
       fin
      chaine_restante		est chaîne	= Milieu( text_ligne_courante, m_lexer:numéro_colonne_en_cours)		
      :dernière_erreur = ChaîneConstruit("ligne %1: %2"+rc+ "%3" , m_lexer:numéro_ligne_en_cours, text_ligne_courante, message_erreur ) 
     type : 458752
   -
     name : get_texte_erreur
     procedure_id : 1349920938546886586
     type_code : 12
     code : |1+
      // renvoie le texte de la dernière erreur
      procédure get_texte_erreur() : chaîne
      // si on a une erreur de comilation
      si :dernière_erreur<>"" ALORS
      	renvoyer :dernière_erreur
      	
      FIN
      
      // erreur du lexer
      renvoyer m_lexer:dernière_erreur_lex
     type : 458752
  procedure_templates : []
  property_templates : []
 code_parameters :
  internal_properties : BwAAAAcAAAA6ih3UbgNXHwTtiPSFUEj+2fi/m7v4QV2rqidAupM=
  original_name : Classe1
resources :
 string_res :
  identifier : 0x12ba8dc50078330e
  internal_properties : BwAAAAcAAAAnMYFQ1bL/vz9ehh7L22SNNSlIzGTOI8h5F/WtgDNP
custom_note :
 internal_properties : BwAAAAcAAABtB9HWVzrXO2+4NDRVK0vmzaNKrCKqH1DBX30lMmGZ
